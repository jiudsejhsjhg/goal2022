<script>
//将这段文字编写代码转成对象输出
//www.baidu.com/ search?a=asdf&b=aef&c=3&c=2&c=5&d=wfe
  function parseQueryString(str) {
    var obj = {}
    var pairs = str.split('&')             //从&符拆开，拆开后得到数组
    pairs.forEach(function(pairs) {     //遍历pairs
      var [key, val] = pairs.split('=')   //再将值从等号开始拆分  ,得出数组，左边的是属性名，右边是值
      if (key in obj) {  //如果obj里有key的字段了我们应该将这字段转化成数组

        if (!Array.isArray(obj[key])) {  //如果obj 里的key不是数组
          obj[key] = [   obj[key]   ]  //如果不是数组那就构建一个数组
        }
        obj[key].push(val)   //是数组就往里push

      } else {
        obj[key] = val  // 没有遇到重复的 再把属性名和属性值作为 对象的属性名和值 进对象

      }
    })
    return obj
  }
        //效果示例如下：
 `
{
  a: 'asdf',
  b: 'aef',
  c: [3,2,5],
  d: 'wfe'
}`

//输入的对象转成字符串  {a:1,b:2}  返回  "{"a": 1, "b":2}"
function stringify(obj) {
  if (obj && typeof obj == 'object') { //是对象要分为两种情况
    if(Array.isArray(obj)) {  //那如果是数组
      var result = "["
      for (var i = 0 ; i < obj.length ; i++) {  //将数组遍历一边
        result +=  obj[i]    //数组的值后面拼接
        if (i < obj.length - 1) {  //说明不是最后一项
          result += ','  // 不是最后一项就拼接逗号  ，是最后一项就不拼接逗号
        }
      }
      result += "]"
      return result
    } else {  //反则就是对象
      var result = '{'  // 先等于个花括号，后面再拼接
     for (var key in obj) {           //是对象就映射obj
      var  val = obj[key]  //val就是key属性从obj取出来的值
      result += '"' + key +'":' + val + ','  //
    }
    result = result.slice(0, -1)  //循环结束后将最后一个逗号删除
    result += '}'  //循环结束后再加上花括号  拼接就返回
   return result
    }

  }
}

function stringify(obj)
  {
  if (obj && typeof obj == 'object ' ) {
  if (Array.isArray(obj)) {
  var result = '['
  for (var i = o; i < obj.length; i++) {
    result += stringify(obj[i])
  if (i < obj.length - 1) {result += ','
  }
  }
  result += ']'
  return result
 } else {
  var result = '{'

  for (var key in obj) {var val = obj[key]
  result += '"' + key + '":' + stringify( val) + ','
 }
  result = result.slice(0, -1)
  result += '}'
  return result}
  } else {
  if (typeof obj == 'string') {

    return '"' + obj + '"'
  } else {
  return string(obj)}
  }
}

//过滤出条件大于3的元素  ，然后返回满足的条件元素
function filter(array, test) {
  var result = []
  for (var i = 0 ; i < array.length ;i++) {
    var item = array[i]
    if ( test(array[i], i ,array )   ) {  //test用于测试array【i】的值是否满足条件
      result.push(item)
    }
  }
  return result
 }

 filter([1,2,3,4,5], function (item ,idx) {
  return item > 3
})


// 计算其寿命事件
var result = []
for (var i = 0; i < ancestry.length ; i++) {
  var p = ancestry[i]
  result.push(p.died - p.born)   //计算寿命

}
console.log(result)

//找出其名字
function map (array) {
  var result = []
  for (var i = 0 ; i < ancestry.length ;i++) {
    var p = ancestry[i]
    result.push(p.name)

  }
  console.log(result)
}

//求数组的和
var ary = [11,17,2,7,19,3,14,5]

  var sum = 0
  for (var i = 0 ; i < ary.length ; i++) {
    sum += ary[i]
  }
  console.log(sum)


  //求上数组的乘积   var ary = [11,17,2,7,19,3,14,5]
  var product = 1
  for (var i = 0 ; i < ary.length ;i++) {
    product *= ary[i]
  }
  console.log(product)

  // var ary = [11,17,2,7,19,3,14,5]   求数组的最大值
  function reduce(ary , reduce ,initialValue) {
    var max = initialValue
    for (var i = 0 ; i < ary.length ;i++) {
      if (ary[i] > max) {
        max = reduce(max,ary[i] ,i, ary)
      }
    }
    return max
  }

  var ary = [11,17,2,7,19,3,14,5]
  var map = {}
  for (var i = 0 ; i < ary.length ; i++) {
    map[ary[i]] = i  //map的ary的i是映射的是ary的i
  }


function reduce(ary,reduce ,initialValue) {
  var result = initialValue
  var start = 0
  if (initialValue == undefined) {
    result = ary[0]
    start = 1
  }
  for (var i = start ; i < ary.length; i++) {
    result = reduce(result,ary[i], i ,ary)

  }
  return result
}
reduce([1,2,3,4,5,6] , (result , it) => {
 return result + it    //result是计算返回的新的值，it是输入的数组的值

}, 0 )  //初始值为0  ，可以写也可以不写


//高阶函数   //如果数组中的每个元素传给predicate后都返回真，则every返回真，否则返回假
function every(ary,predicate) {
  for (var i = 0 ; i < ary.length ;i++) {  //先遍历整个数组
     if (predicate(ary[i] ,i , ary) == false) {  //如果等于false,直接返回false   //
      //也可以（！president（ary[i] , i , aaary) 就是转成布尔再取反，就是转成布尔为假那取反为真
        return false
  }  //将ary的项（值）传给predicate，为了方便，也会把数组的下标，和数组本身上传
      return true   //循环结束了也没有返回假那就是true
  }
}
//使用reduce来实现every高阶函数
function every(ary, predicate) {
    return ary.reduce(function(sum,item) {
    return sum && predicate(item)
  }, true)  //true是初始值
}

//第三种写法，在实现了some的情况下
function every(ary,predicate) {
  return !some(ary , (it,i ,ary) => !predicate(it))

}

//  高阶函数   //任何一个为真就返回真  ,如果没有一个能返回真那返回false
function some(ary, predicate) {
   for (var i = 0 ; i < ary.length ; i++ ) {
     if (predicate(ary[i] , i , ary)) {
      return true
     }
   }
   return false
}

function som(ary,predicate) {
  return ary.reduce((sum, item) => {
    return sum || item
  } , false)
}

//第三种写法，在实现every的情况下
function some(ary , predicate) {
  return !every(ary, (it ,i , ary) => !predicate(it))
}

//找到相同的元素返回，找不到返回undefined
function find(ary, predicate) {
  for (var i = 0 ; i < ary.length ; i++) {
    if (predicate(ary[i] , i , ary)) {
      return ary[i]
    }
  }
}

function findIndex(ary, predicate) {
  for (var i = 0 ; i < ary.length ; i++) {
    
  }
}

//将上篇的松鼠人代码使用forEach改写
function gatherCorrelations(journal) {
  var phis = {}
  for (var entry = 0 ; entry < journal.length; entry++) {
    var events = journal[entry].events  //每次拿到当天的evevts
  for (var i = 0 ; i < events.length ; i++) {
    var event = events[i]
    if (!(event in phis)) {
      phis[event] = phis(tableFor(event,journal))
    }
  }
  }
  return phis
}

function gatherCorrelations(journal) {
  var phis = {}
  journal.forEach(function(entry) {
    entry.nents.forEach(function(nent) {
      if (!(event in phis)) {
        phis[event] = phis(tableFor(event,journal))
      }
    })
  })
  return phis
}





// 二叉树array中的根节点在rootpos位置的二叉树转换为二叉链表形式   将数组转成二叉树形式
将存储于array中
function arrayToTree(array ,rootPos = 0) {
  if (array[rootPos] == null) {
    return null
  }
  var root = {
    val: array[rootPos],
    left: null,
    right: null,

  }

  root.left = arrayToTree[array,root * 2 + 1]
  root.right = arrayToTree(array[rootPos * 2 + 2])

  return root


}


//将二叉树形似的对象转成数组保存

function f() {
  var array = []
  function treeToArray(root,pos = 0) {

    array[pos] = root.val
    treeToArray(root.left,)

}

}


function arrayToTree(ary) {

}



function f(array) {

  for (var i = 0 ; i < arry.length; i++) {

  }
}






</script>
